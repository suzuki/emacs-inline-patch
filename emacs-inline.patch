diff --git a/configure.ac b/configure.ac
index a11abc1b65..8574e8bd8c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2009,7 +2009,7 @@ AC_DEFUN
      INSTALL_ARCH_INDEP_EXTRA=
   fi
 
-  NS_OBJC_OBJ="nsterm.o nsfns.o nsmenu.o nsselect.o nsimage.o $ns_fontfile"
+  NS_OBJC_OBJ="nsterm.o nsfns.o nsmenu.o nsselect.o nsimage.o macim.o $ns_fontfile"
 fi
 CFLAGS="$tmp_CFLAGS"
 CPPFLAGS="$tmp_CPPFLAGS"
@@ -5270,7 +5270,7 @@ AC_DEFUN
    ## only costs about 1.5K of wasted binary space.
    headerpad_extra=1000
    if test "$HAVE_NS" = "yes"; then
-     libs_nsgui="-framework AppKit"
+     libs_nsgui="-framework AppKit -framework Carbon -framework Cocoa"
      if test "$NS_IMPL_COCOA" = "yes"; then
         libs_nsgui="$libs_nsgui -framework IOKit -framework Carbon"
      fi
diff --git a/lisp/term/common-win.el b/lisp/term/common-win.el
index 6ef686a996..ba6754144b 100644
--- a/lisp/term/common-win.el
+++ b/lisp/term/common-win.el
@@ -73,6 +73,7 @@ x-setup-function-keys
 	       (cons (logior (lsh 0 16)  12) 'ns-new-frame)
 	       (cons (logior (lsh 0 16)  13) 'ns-toggle-toolbar)
 	       (cons (logior (lsh 0 16)  14) 'ns-show-prefs)
+	       (cons (logior (lsh 0 16)  15) 'mac-change-input-method)
 	       ))))
     (set-terminal-parameter frame 'x-setup-function-keys t)))
 
diff --git a/lisp/term/ns-win.el b/lisp/term/ns-win.el
index eff8adcd3b..76f66597ac 100644
--- a/lisp/term/ns-win.el
+++ b/lisp/term/ns-win.el
@@ -171,6 +171,7 @@ global-map
 (define-key global-map [ns-new-frame] 'make-frame)
 (define-key global-map [ns-toggle-toolbar] 'ns-toggle-toolbar)
 (define-key global-map [ns-show-prefs] 'customize)
+(define-key global-map [mac-change-input-method] 'mac-change-input-method)
 
 
 ;; Set up a number of aliases and other layers to pretend we're using
@@ -265,14 +266,30 @@ ns-spi-service-call
 ;; editing window.)
 
 (defface ns-working-text-face
-  '((t :underline t))
+  '((((background dark)) :underline "gray80")
+    (t :underline "gray20"))
   "Face used to highlight working text during compose sequence insert."
   :group 'ns)
 
+(defface ns-marked-text-face
+  '((((background dark)) :underline "gray80")
+    (t :underline "gray20"))
+  "Face used to highlight marked text during compose sequence insert."
+  :group 'ns)
+
+(defface ns-unmarked-text-face
+  '((((background dark)) :underline "gray20")
+    (t :underline "gray80"))
+  "Face used to highlight marked text during compose sequence insert."
+  :group 'ns)
+
 (defvar ns-working-overlay nil
   "Overlay used to highlight working text during compose sequence insert.
 When text is in th echo area, this just stores the length of the working text.")
 
+(defvar ns-marked-overlay nil
+  "Overlay used to highlight marked text during compose sequence insert.")
+
 (defvar ns-working-text)		; nsterm.m
 
 ;; Test if in echo area, based on mac-win.el 2007/08/26 unicode-2.
@@ -280,17 +297,19 @@ ns-working-text
 (defun ns-in-echo-area ()
   "Whether, for purposes of inserting working composition text, the minibuffer
 is currently being used."
-  (or isearch-mode
-      (and cursor-in-echo-area (current-message))
-      ;; Overlay strings are not shown in some cases.
-      (get-char-property (point) 'invisible)
-      (and (not (bobp))
-	   (or (and (get-char-property (point) 'display)
-		    (eq (get-char-property (1- (point)) 'display)
-			(get-char-property (point) 'display)))
-	       (and (get-char-property (point) 'composition)
-		    (eq (get-char-property (1- (point)) 'composition)
-			(get-char-property (point) 'composition)))))))
+  (setq mac-in-echo-area 
+	(or isearch-mode
+	    (and cursor-in-echo-area (current-message))
+	    ;; Overlay strings are not shown in some cases.
+	    (get-char-property (point) 'invisible)
+	    (and (not (bobp))
+		 (or (and (get-char-property (point) 'display)
+			  (eq (get-char-property (1- (point)) 'display)
+			      (get-char-property (point) 'display)))
+		     (and (get-char-property (point) 'composition)
+			  (eq (get-char-property (1- (point)) 'composition)
+			      (get-char-property (point) 'composition)))))))
+  mac-in-echo-area)
 
 ;; The 'interactive' here stays for subinvocations, so the ns-in-echo-area
 ;; always returns nil for some reason.  If this WASN'T the case, we could
@@ -299,6 +318,7 @@ ns-in-echo-area
 (defun ns-put-working-text ()
   (interactive)
   (if (ns-in-echo-area) (ns-echo-working-text) (ns-insert-working-text)))
+
 (defun ns-unput-working-text ()
   (interactive)
   (ns-delete-working-text))
@@ -320,19 +340,81 @@ ns-insert-working-text
 (defun ns-echo-working-text ()
   "Echo contents of `ns-working-text' in message display area.
 See `ns-insert-working-text'."
-  (ns-delete-working-text)
   (let* ((msg (current-message))
-	 (msglen (length msg))
-	 message-log-max)
+         (msglen (length msg))
+         message-log-max)
+    (if (integerp ns-working-overlay)
+	(progn
+	  (setq msg (substring msg 0 (- (length msg) ns-working-overlay)))
+	  (setq msglen (length msg))))
     (setq ns-working-overlay (length ns-working-text))
     (setq msg (concat msg ns-working-text))
     (put-text-property msglen (+ msglen ns-working-overlay)
-		       'face 'ns-working-text-face msg)
+			'face 'ns-working-text-face msg)
+     (message "%s" msg)))
+
+(defun ns-put-marked-text (event)
+  (interactive "e")
+
+  (let ((pos (nth 1 event))
+	(len (nth 2 event)))
+    (if (ns-in-echo-area)
+	(ns-echo-marked-text pos len)
+      (ns-insert-marked-text pos len))))
+
+(defun ns-insert-marked-text (pos len)
+  "Insert contents of `ns-working-text' as UTF-8 string and mark with
+`ns-working-overlay' and `ns-marked-overlay'.  Any previously existing
+working text is cleared first. The overlay is assigned the faces 
+`ns-working-text-face' and `ns-marked-text-face'."
+  (ns-delete-working-text)
+  (let ((start (point)))
+    (if (<= pos (length ns-working-text))
+      (progn
+	(put-text-property pos len 'face 'ns-working-text-face ns-working-text)
+	(insert ns-working-text)
+	(if (= len 0)
+	    (overlay-put (setq ns-working-overlay
+			       (make-overlay start (point) (current-buffer) nil t))
+			 'face 'ns-working-text-face)
+	  (overlay-put (setq ns-working-overlay
+			     (make-overlay start (point) (current-buffer) nil t))
+		       'face 'ns-unmarked-text-face)
+	  (overlay-put (setq ns-marked-overlay 
+			     (make-overlay (+ start pos) (+ start pos len)
+					   (current-buffer) nil t))
+		       'face 'ns-marked-text-face))
+	(goto-char (+ start pos))))))
+    
+(defun ns-echo-marked-text (pos len)
+  "Echo contents of `ns-working-text' in message display area.
+See `ns-insert-working-text'."
+  (let* ((msg (current-message))
+         (msglen (length msg))
+         message-log-max)
+    (when (integerp ns-working-overlay)
+      (setq msg (substring msg 0 (- (length msg) ns-working-overlay)))
+      (setq msglen (length msg)))
+    (setq ns-working-overlay (length ns-working-text))
+    (setq msg (concat msg ns-working-text))
+    (if (= len 0)
+        (put-text-property msglen (+ msglen ns-working-overlay)
+                           'face 'ns-working-text-face msg)
+      (put-text-property msglen (+ msglen ns-working-overlay)
+                         'face 'ns-unmarked-text-face msg)
+      (put-text-property (+ msglen pos) (+ msglen pos len)
+                         'face 'ns-marked-text-face msg))
     (message "%s" msg)))
 
 (defun ns-delete-working-text()
-  "Delete working text and clear `ns-working-overlay'."
+  "Delete working text and clear `ns-working-overlay' and `ns-marked-overlay'."
   (interactive)
+  (when (and (overlayp ns-marked-overlay)
+	     ;; Still alive
+	     (overlay-buffer ns-marked-overlay))
+    (with-current-buffer (overlay-buffer ns-marked-overlay)
+      (delete-overlay ns-marked-overlay)))
+  (setq ns-marked-overlay nil)
   (cond
    ((and (overlayp ns-working-overlay)
          ;; Still alive?
@@ -923,6 +1005,566 @@ ns-initialized
                                          &context (window-system ns))
   (ns-get-selection selection-symbol target-type))
 
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Implementation of Input Method Extension for MacOS X
+;; written by Taiichi Hashimoto <taiichi2@mac.com>
+;;
+
+(defvar mac-input-method-parameters
+  '(
+    ("com.apple.inputmethod.Kotoeri.Roman"
+     (title . "A")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.Kotoeri.Japanese"
+     (title . "あ")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.Kotoeri.Japanese.Katakana"
+     (title . "ア")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.Kotoeri.Japanese.FullWidthRoman"
+     (title . "Ａ")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.Kotoeri.Japanese.HalfWidthKana"
+     (title . "ｱ")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.kotoeri.Ainu"
+     (title . "アイヌ")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.Korean.2SetKorean"
+     (title . "가2")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.Korean.3SetKorean"
+     (title . "가3")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.Korean.390Sebulshik"
+     (title . "가5")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.Korean.GongjinCheongRomaja"
+     (title . "가G")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.Korean.HNCRomaja"
+     (title . "가H")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.Tamil.AnjalIM"
+     (title . "Anjal")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.Tamil.Tamil99"
+     (title . "Tamil")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.VietnameseIM.VietnameseSimpleTelex"
+     (title . "ST")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.VietnameseIM.VietnameseTelex"
+     (title . "TX")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.VietnameseIM.VietnameseVNI"
+     (title . "VN")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.VietnameseIM.VietnameseVIQR"
+     (title . "VQ")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.SCIM.ITABC"
+     (title . "拼")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.SCIM.WBX"
+     (title . "型")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.SCIM.WBH"
+     (title . "画")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.TCIM.Zhuyin"
+     (title . "注")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.TCIM.Pinyin"
+     (title . "拼")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.TCIM.Cangjie"
+     (title . "倉")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.TCIM.Jianyi"
+     (title . "速")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.TCIM.Dayi"
+     (title . "易")
+     (cursor-color)
+     (cursor-type))
+    ("com.apple.inputmethod.TCIM.Hanin"
+     (title . "漢")
+     (cursor-color)
+     (cursor-type))
+    ("com.google.inputmethod.Japanese.Roman"
+     (title . "G")
+     (cursor-color)
+     (cursor-type))
+    ("com.google.inputmethod.Japanese.base"
+     (title . "ぐ")
+     (cursor-color)
+     (cursor-type))
+    ("com.google.inputmethod.Japanese.Katakana"
+     (title . "グ")
+     (cursor-color)
+     (cursor-type))
+    ("com.google.inputmethod.Japanese.FullWidthRoman"
+     (title . "Ｇ")
+     (cursor-color)
+     (cursor-type))
+    ("com.google.inputmethod.Japanese.HalfWidthKana"
+     (title . "ｸﾞ")
+     (cursor-color)
+     (cursor-type))
+    ("jp.monokakido.inputmethod.Kawasemi.Roman"
+     (title . "K")
+     (cursor-color)
+     (cursor-type))
+    ("jp.monokakido.inputmethod.Kawasemi.Japanese"
+     (title . "か")
+     (cursor-color)
+     (cursor-type))
+    ("jp.monokakido.inputmethod.Kawasemi.Japanese.Katakana"
+     (title . "カ")
+     (cursor-color)
+     (cursor-type))
+    ("jp.monokakido.inputmethod.Kawasemi.Japanese.FullWidthRoman"
+     (title . "Ｋ")
+     (cursor-color)
+     (cursor-type))
+    ("jp.monokakido.inputmethod.Kawasemi.Japanese.HalfWidthKana"
+     (title . "ｶ")
+     (cursor-color)
+     (cursor-type))
+    ("jp.monokakido.inputmethod.Kawasemi.Japanese.HalfWidthRoman"
+     (title . "_K")
+     (cursor-color)
+     (cursor-type))
+    ("jp.monokakido.inputmethod.Kawasemi.Japanese.Code"
+     (title . "C")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok21.Roman"
+     (title . "A")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok21.Japanese"
+     (title . "あ")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok21.Japanese.Katakana"
+     (title . "ア")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok21.Japanese.FullWidthRoman"
+     (title . "英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok21.Japanese.HalfWidthEiji"
+     (title . "半英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok22.Roman"
+     (title . "A")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok22.Japanese"
+     (title . "あ")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok22.Japanese.Katakana"
+     (title . "ア")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok22.Japanese.FullWidthRoman"
+     (title . "英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok22.Japanese.HalfWidthEiji"
+     (title . "半英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok23.Roman"
+     (title . "A")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok23.Japanese"
+     (title . "あ")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok23.Japanese.Katakana"
+     (title . "ア")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok23.Japanese.FullWidthRoman"
+     (title . "英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok23.Japanese.HalfWidthEiji"
+     (title . "半英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok24.Roman"
+     (title . "A")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok24.Japanese"
+     (title . "あ")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok24.Japanese.Katakana"
+     (title . "ア")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok24.Japanese.FullWidthRoman"
+     (title . "英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok24.Japanese.HalfWidthEiji"
+     (title . "半英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok25.Roman"
+     (title . "A")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok25.Japanese"
+     (title . "あ")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok25.Japanese.Katakana"
+     (title . "ア")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok25.Japanese.FullWidthRoman"
+     (title . "英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok25.Japanese.HalfWidthEiji"
+     (title . "半英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok26.Roman"
+     (title . "A")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok26.Japanese"
+     (title . "あ")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok26.Japanese.Katakana"
+     (title . "ア")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok26.Japanese.FullWidthRoman"
+     (title . "英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok26.Japanese.HalfWidthEiji"
+     (title . "半英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok27.Roman"
+     (title . "A")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok27.Japanese"
+     (title . "あ")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok27.Japanese.Katakana"
+     (title . "ア")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok27.Japanese.FullWidthRoman"
+     (title . "英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok27.Japanese.HalfWidthEiji"
+     (title . "半英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok28.Roman"
+     (title . "A")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok28.Japanese"
+     (title . "あ")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok28.Japanese.Katakana"
+     (title . "ア")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok28.Japanese.FullWidthRoman"
+     (title . "英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok28.Japanese.HalfWidthEiji"
+     (title . "半英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok29.Roman"
+     (title . "A")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok29.Japanese"
+     (title . "あ")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok29.Japanese.Katakana"
+     (title . "ア")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok29.Japanese.FullWidthRoman"
+     (title . "英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok29.Japanese.HalfWidthEiji"
+     (title . "半英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok30.Roman"
+     (title . "A")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok30.Japanese"
+     (title . "あ")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok30.Japanese.Katakana"
+     (title . "ア")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok30.Japanese.FullWidthRoman"
+     (title . "英")
+     (cursor-color)
+     (cursor-type))
+    ("com.justsystems.inputmethod.atok30.Japanese.HalfWidthEiji"
+     (title . "半英")
+     (cursor-color)
+     (cursor-type))
+    )
+  "Alist of Mac script code vs parameters for input method on MacOSX.")
+
+
+(defun mac-get-input-method-parameter (is key)
+  "Function to get a parameter of a input method."
+  (interactive)
+  (assq key (cdr (assoc is mac-input-method-parameters))))
+
+(defun mac-get-input-method-title (&optional input-source)
+  "Return input method title of input source.
+   If input-source is nil, return one of current frame."
+  (if input-source
+      (cdr (mac-get-input-method-parameter input-source 'title))
+    current-input-method-title))
+
+(defun mac-get-cursor-type (&optional input-source)
+  "Return cursor type of input source.
+   If input-source is nil, return one of current frame."
+  (if input-source
+      (or (cdr (mac-get-input-method-parameter input-source 'cursor-type))
+	  (cdr (assq 'cursor-type default-frame-alist))
+	  cursor-type)
+    (cdr (assq 'cursor-type (frame-parameters (selected-frame))))))
+
+(defun mac-get-cursor-color (&optional input-source)
+  "Return cursor color of input source.
+   If input-source is nil, return one of current frame."
+  (if input-source
+      (or (cdr (mac-get-input-method-parameter input-source 'cursor-color))
+	  (cdr (assq 'cursor-color default-frame-alist)))
+    (cdr (assq 'cursor-color (frame-parameters (selected-frame))))))
+
+
+(defun mac-set-input-method-parameter (is key value)
+  "Function to set a parameter of a input method."
+  (let* ((is-param (assoc is mac-input-method-parameters))
+         (param (assq key is-param)))
+    (if is-param
+	(if param
+	    (setcdr param value)
+	  (setcdr is-param (cons (cons key value) (cdr is-param))))
+      (setq mac-input-method-parameters
+	    (cons (list is (cons key value))
+		  mac-input-method-parameters)))))
+
+
+(defun mac-input-method-update (is)
+  "Funtion to update parameters of a input method."
+  (interactive)
+
+  (let ((title (mac-get-input-method-title is))
+        (type (mac-get-cursor-type is))
+        (color (mac-get-cursor-color is)))
+    (if (and title (not (equal title (mac-get-input-method-title))))
+	(setq current-input-method-title title))
+    (if (and type (not (equal type (mac-get-cursor-type))))
+	(setq cursor-type type))
+    (if (and color (not (equal color (mac-get-cursor-color))))
+	(set-cursor-color color))
+    (force-mode-line-update)
+    (if isearch-mode (isearch-update))))
+
+
+(defun mac-toggle-input-method (&optional arg)
+  "Function to toggle input method on MacOSX."
+  (interactive)
+  
+  (if arg
+      (progn
+	(make-local-variable 'input-method-function)
+	(setq inactivate-current-input-method-function 'mac-toggle-input-method)
+	(setq input-method-function nil)
+	(setq describe-current-input-method-function nil)
+	(mac-toggle-input-source t))
+    (kill-local-variable 'input-method-function)
+    (setq describe-current-input-method-function nil)
+    (mac-toggle-input-source nil)))
+
+
+(defun mac-change-language-to-us ()
+  "Function to change language to us."
+  (interactive)
+  (mac-toggle-input-method nil))
+
+
+(defun mac-handle-input-method-change ()
+  "Function run when a input method change."
+  (interactive)
+
+  (if (equal default-input-method "MacOSX")
+      (let ((input-source (mac-get-current-input-source))
+	  (ascii-capable (mac-input-source-is-ascii-capable)))
+	
+	(cond ((and (not current-input-method) (not ascii-capable))
+	       (set-input-method "MacOSX"))
+	      ((and (equal current-input-method "MacOSX") ascii-capable)
+	       (toggle-input-method nil)))
+	(mac-input-method-update input-source))))
+
+;;
+;; Emacs input method for input method on MacOSX.
+;;
+(register-input-method "MacOSX" "MacOSX" 'mac-toggle-input-method
+		       "Mac" "Input Method on MacOSX System")
+
+
+;;
+;; Minor mode of using input methods on MacOS X
+;;
+(define-minor-mode mac-input-method-mode
+  "Use input methods on MacOSX."
+  :init-value nil
+  :group 'ns
+  :global t
+
+  (if mac-input-method-mode
+      (progn
+	(setq default-input-method "MacOSX")
+	(add-hook 'minibuffer-setup-hook 'mac-change-language-to-us)
+	(mac-translate-from-yen-to-backslash))
+    (setq default-input-method nil)))
+
+;;
+;; Valiable and functions to pass key(shortcut) to system.
+;;
+(defvar mac-keys-passed-to-system nil
+  "A list of keys passed to system on MacOSX.")
+
+(defun mac-add-key-passed-to-system (key)
+  (let ((shift   '(shift shft))
+	(control '(control ctrl ctl))
+	(option  '(option opt alternate alt))
+	(command '(command cmd)))
+
+    (add-to-list 'mac-keys-passed-to-system
+		 (cond ((symbolp key)
+			(cond ((memq key shift)
+			       (cons ns-shift-key-mask nil))
+			      ((memq key control)
+			       (cons ns-control-key-mask nil))
+			      ((memq key option)
+			       (cons ns-alternate-key-mask nil))
+			      ((memq key command)
+			       (cons ns-command-key-mask nil))
+			      (t (cons nil nil))))
+		       ((numberp key) (cons 0 key))
+		       ((listp key)
+			(let ((l key) (k nil) (m 0))
+			  (while l
+			    (cond ((memq (car l) shift)
+				   (setq m (logior m ns-shift-key-mask)))
+				  ((memq (car l) control)
+				   (setq m (logior m ns-control-key-mask)))
+				  ((memq (car l) option)
+				   (setq m (logior m ns-alternate-key-mask)))
+				  ((memq (car l) command)
+				       (setq m (logior m ns-command-key-mask)))
+				  ((numberp (car l))
+				   (if (not k) (setq k (car l)))))
+			    (setq l (cdr l)))
+			  (cons m k)))
+		       (t (cons nil nil))))))
+
+
+;;
+;; Entry Emacs event for inline input method on MacOSX.
+;;
+(define-key special-event-map
+  [mac-change-input-method] 'mac-handle-input-method-change)
+      
+;;
+;; Convert yen to backslash for JIS keyboard.
+;;
+(defun mac-translate-from-yen-to-backslash () 
+  ;; Convert yen to backslash for JIS keyboard.
+  (interactive)
+
+  (define-key global-map [165] nil)
+  (define-key global-map [2213] nil)
+  (define-key global-map [3420] nil)
+  (define-key global-map [67109029] nil)
+  (define-key global-map [67111077] nil)
+  (define-key global-map [8388773] nil)
+  (define-key global-map [134219941] nil)
+  (define-key global-map [75497596] nil)
+  (define-key global-map [201328805] nil)
+  (define-key function-key-map [165] [?\\])
+  (define-key function-key-map [2213] [?\\]) ;; for Intel
+  (define-key function-key-map [3420] [?\\]) ;; for PowerPC
+  (define-key function-key-map [67109029] [?\C-\\])
+  (define-key function-key-map [67111077] [?\C-\\])
+  (define-key function-key-map [8388773] [?\M-\\])
+  (define-key function-key-map [134219941] [?\M-\\])
+  (define-key function-key-map [75497596] [?\C-\M-\\])
+  (define-key function-key-map [201328805] [?\C-\M-\\])
+)
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
 (provide 'ns-win)
 (provide 'term/ns-win)
 
diff --git a/src/Makefile.in b/src/Makefile.in
index 1d23425969..f84818bae6 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -413,7 +413,7 @@ obj =
 SOME_MACHINE_OBJECTS = dosfns.o msdos.o \
   xterm.o xfns.o xmenu.o xselect.o xrdb.o xsmfns.o fringe.o image.o \
   fontset.o dbusbind.o cygw32.o \
-  nsterm.o nsfns.o nsmenu.o nsselect.o nsimage.o nsfont.o macfont.o \
+  nsterm.o nsfns.o nsmenu.o nsselect.o nsimage.o nsfont.o macfont.o macim.o \
   w32.o w32console.o w32cygwinx.o w32fns.o w32heap.o w32inevt.o w32notify.o \
   w32menu.o w32proc.o w32reg.o w32select.o w32term.o w32xfns.o \
   w16select.o widget.o xfont.o ftfont.o xftfont.o ftxfont.o gtkutil.o \
diff --git a/src/image.c b/src/image.c
index 992b225d7b..4abd979479 100644
--- a/src/image.c
+++ b/src/image.c
@@ -8272,14 +8272,14 @@ imagemagick_image_p (Lisp_Object object)
 /* The GIF library also defines DrawRectangle, but its never used in Emacs.
    Therefore rename the function so it doesn't collide with ImageMagick.  */
 #define DrawRectangle DrawRectangleGif
-#include <wand/MagickWand.h>
+#include <MagickWand/MagickWand.h>
 
 /* ImageMagick 6.5.3 through 6.6.5 hid PixelGetMagickColor for some reason.
    Emacs seems to work fine with the hidden version, so unhide it.  */
-#include <magick/version.h>
+#include <MagickCore/version.h>
 #if 0x653 <= MagickLibVersion && MagickLibVersion <= 0x665
 extern WandExport void PixelGetMagickColor (const PixelWand *,
-					    MagickPixelPacket *);
+					    PixelInfo *);
 #endif
 
 /* Log ImageMagick error message.
@@ -8434,7 +8434,7 @@ imagemagick_compute_animated_image (MagickWand *super_wand, int ino)
       PixelWand **source, **dest;
       size_t source_width, source_height;
       ssize_t source_left, source_top;
-      MagickPixelPacket pixel;
+      PixelInfo pixel;
       DisposeType dispose;
       ptrdiff_t lines = 0;
 
@@ -8499,7 +8499,7 @@ imagemagick_compute_animated_image (MagickWand *super_wand, int ino)
 	      if (dispose == BackgroundDispose || PixelGetAlpha (source[x]))
 		{
 		  PixelGetMagickColor (source[x], &pixel);
-		  PixelSetMagickColor (dest[x + source_left], &pixel);
+		  PixelSetPixelColor (dest[x + source_left], &pixel);
 		}
 	    }
 	  PixelSyncIterator (dest_iterator);
@@ -8546,7 +8546,7 @@ imagemagick_load_image (struct frame *f, struct image *img,
   MagickWand *image_wand;
   PixelIterator *iterator;
   PixelWand **pixels, *bg_wand = NULL;
-  MagickPixelPacket  pixel;
+  PixelInfo  pixel;
   Lisp_Object image;
   Lisp_Object value;
   Lisp_Object crop;
diff --git a/src/keyboard.c b/src/keyboard.c
index c0c863f0d3..9a606b8b86 100644
--- a/src/keyboard.c
+++ b/src/keyboard.c
@@ -5469,9 +5469,16 @@ make_lispy_event (struct input_event *event)
 
 #ifdef HAVE_NS
     case NS_TEXT_EVENT:
-      return list1 (intern (event->code == KEY_NS_PUT_WORKING_TEXT
-                            ? "ns-put-working-text"
-                            : "ns-unput-working-text"));
+      /* return list1 (intern (event->code == KEY_NS_PUT_WORKING_TEXT */
+      /*                       ? "ns-put-working-text" */
+      /*                       : "ns-unput-working-text")); */
+
+      if (event->code == KEY_NS_PUT_WORKING_TEXT)
+	return list1 (intern ("ns-put-working-text"));
+      else if (event->code == KEY_NS_UNPUT_WORKING_TEXT)
+	return list1 (intern ("ns-unput-working-text"));
+      else if (event->code == KEY_NS_PUT_MARKED_TEXT)
+	return Fcons (intern ("ns-put-marked-text"), event->arg);
 
       /* NS_NONKEY_EVENTs are just like NON_ASCII_KEYSTROKE_EVENTs,
 	 except that they are non-key events (last-nonmenu-event is nil).  */
@@ -11915,6 +11922,8 @@ keys_of_keyboard (void)
 			    "ns-put-working-text");
   initial_define_lispy_key (Vspecial_event_map, "ns-unput-working-text",
 			    "ns-unput-working-text");
+  initial_define_lispy_key (Vspecial_event_map, "ns-put-marked-text",
+			    "ns-put-marked-text");
   /* Here we used to use `ignore-event' which would simple set prefix-arg to
      current-prefix-arg, as is done in `handle-switch-frame'.
      But `handle-switch-frame is not run from the special-map.
diff --git a/src/macim.m b/src/macim.m
index e69de29bb2..fa4670b251 100644
--- a/src/macim.m
+++ b/src/macim.m
@@ -0,0 +1,173 @@
+/* Implementation of Input Method Extension for MacOS X.
+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
+   Taiichi Hashimoto <taiichi2@mac.com>.
+*/
+
+#include "config.h"
+
+#ifdef NS_IMPL_COCOA
+
+#include <math.h>
+#include <sys/types.h>
+#include <time.h>
+#include <signal.h>
+#include <unistd.h>
+
+#include <Carbon/Carbon.h>
+
+#include "lisp.h"
+#include "blockinput.h"
+
+#include "termhooks.h"
+#include "keyboard.h"
+#include "buffer.h"
+
+//extern Lisp_Object Qcurrent_input_method;
+//extern int cursor_in_echo_area;
+static Lisp_Object Qmac_keys_passed_to_system;
+
+void mac_init_input_method ();
+int mac_pass_key_to_system (int code, int modifiers);
+int mac_pass_key_directly_to_emacs ();
+int mac_store_change_input_method_event ();
+
+DEFUN ("mac-input-source-is-ascii-capable", Fmac_input_source_is_ascii_capable, Smac_input_source_is_ascii_capable,
+       0, 0, 0,
+       doc: /* Is current input source ascii capable? */)
+     (void)
+{
+  TISInputSourceRef is = TISCopyCurrentKeyboardInputSource();
+  CFBooleanRef ret = TISGetInputSourceProperty(is, kTISPropertyInputSourceIsASCIICapable);
+  
+  return CFBooleanGetValue(ret)? Qt : Qnil;
+}
+
+DEFUN ("mac-get-input-source-list", Fmac_get_input_source_list, Smac_get_input_source_list,
+       0, 0, 0,
+       doc: /* get input source list on MacOSX */)
+     (void)
+{
+  NSArray *is_list = (NSArray *)TISCreateInputSourceList(NULL, false);
+  int list_size = [is_list count];
+  Lisp_Object list[list_size];
+  int i;
+
+  for (i = 0; i < list_size; i++) {
+    TISInputSourceRef is = (TISInputSourceRef)[is_list objectAtIndex:i];
+    NSString *id = (NSString *)TISGetInputSourceProperty(is, kTISPropertyInputSourceID);
+    list[i] = make_string([id UTF8String],
+			  [id lengthOfBytesUsingEncoding:NSUTF8StringEncoding]);
+  }
+
+  return Flist(list_size, list);
+}
+
+DEFUN ("mac-get-current-input-source", Fmac_get_current_input_source, Smac_get_current_input_source,
+       0, 0, 0,
+       doc: /* get current input source on MacOSX */)
+     (void)
+{
+  TISInputSourceRef is = TISCopyCurrentKeyboardInputSource();
+  NSString *id = (NSString *)TISGetInputSourceProperty(is, kTISPropertyInputSourceID);
+
+  return make_string([id UTF8String],
+		     [id lengthOfBytesUsingEncoding:NSUTF8StringEncoding]);
+}
+
+DEFUN ("mac-toggle-input-source", Fmac_toggle_input_source, Smac_toggle_input_source,
+       1, 1, 0,
+       doc: /* toggle input source on MacOSX */)
+     (arg)
+     Lisp_Object arg;
+{
+  TISInputSourceRef is = NULL;
+
+  if (NILP (arg))
+    {
+      is = TISCopyCurrentASCIICapableKeyboardInputSource();
+    }
+  else
+    {
+      NSString *locale;
+      NSArray *languages = [NSLocale preferredLanguages];
+      if (languages != nil) {
+	  locale = [languages objectAtIndex:0];
+      } else {
+	  locale = [[NSLocale currentLocale]
+		  	objectForKey:NSLocaleLanguageCode];
+      }
+      is = TISCopyInputSourceForLanguage((CFStringRef)locale);
+    }
+  if (is) TISSelectInputSource(is);
+
+  return arg;
+}
+
+int
+mac_store_change_input_method_event ()
+{
+  Lisp_Object dim;
+  int ret = FALSE;
+  
+  dim = Fsymbol_value (intern ("default-input-method"));
+  if (STRINGP (dim) && strcmp(SDATA (dim), "MacOSX") == 0)
+    {
+      ret = TRUE;
+    }
+
+  return ret;
+}
+
+int
+mac_pass_key_to_system (int code, int modifiers)
+{
+  Lisp_Object keys = Fsymbol_value (Qmac_keys_passed_to_system);
+  Lisp_Object m, k; 
+
+  while (!NILP (keys))
+    {
+      m = XCAR (XCAR (keys));
+      k = XCDR (XCAR (keys));
+      keys = XCDR (keys);
+
+      if (NUMBERP (m) && modifiers == XINT (m))
+	if (NILP (k)
+	    || (NUMBERP (k) && code == XINT (k)))
+	  return TRUE;
+    }
+  
+  return FALSE;
+}
+
+int
+mac_pass_key_directly_to_emacs (void)
+{
+
+  if (NILP (Fmac_input_source_is_ascii_capable()))
+    {
+      if (NILP (Vmac_use_input_method_on_system)
+	  || this_command_key_count 
+	  || cursor_in_echo_area 
+	  || !NILP (BVAR (current_buffer, read_only)))
+	return TRUE;
+    }
+
+  return FALSE;
+}
+
+
+void mac_init_input_method (void)
+{
+  Qmac_keys_passed_to_system = intern ("mac-keys-passed-to-system");
+  staticpro (&Qmac_keys_passed_to_system);
+
+  DEFVAR_LISP ("mac-use-input-method-on-system", Vmac_use_input_method_on_system,
+               doc: /* If it is non-nil, use input method on system. */);
+  Vmac_use_input_method_on_system = Qt;
+
+  defsubr (&Smac_input_source_is_ascii_capable);
+  defsubr (&Smac_get_input_source_list);
+  defsubr (&Smac_get_current_input_source);
+  defsubr (&Smac_toggle_input_source);
+}
+#endif
diff --git a/src/nsfns.m b/src/nsfns.m
index 9ff7e88a8d..577c703771 100644
--- a/src/nsfns.m
+++ b/src/nsfns.m
@@ -3164,6 +3164,24 @@ - (NSString *)panel: (id)sender userEnteredFilename: (NSString *)filename
 Default is t.  */);
   ns_use_proxy_icon = true;
 
+
+  DEFVAR_LISP ("ns-shift-key-mask", Vns_shift_key_mask,
+               doc: /* Shift key mask defined in system. */);
+  Vns_shift_key_mask = make_number (NSShiftKeyMask);
+
+  DEFVAR_LISP ("ns-control-key-mask", Vns_control_key_mask,
+               doc: /* Control key mask defined in system. */);
+  Vns_control_key_mask = make_number (NSControlKeyMask);
+
+  DEFVAR_LISP ("ns-alternate-key-mask", Vns_alternate_key_mask,
+               doc: /* Alternate key mask defined in system. */);
+  Vns_alternate_key_mask = make_number (NSAlternateKeyMask);
+
+  DEFVAR_LISP ("ns-command-key-mask", Vns_command_key_mask,
+               doc: /* Command key mask defined in system. */);
+  Vns_command_key_mask = make_number (NSCommandKeyMask);
+
+
   defsubr (&Sns_read_file_name);
   defsubr (&Sns_get_resource);
   defsubr (&Sns_set_resource);
@@ -3213,6 +3231,10 @@ - (NSString *)panel: (id)sender userEnteredFilename: (NSString *)filename
   defsubr (&Sx_show_tip);
   defsubr (&Sx_hide_tip);
 
+#ifdef NS_IMPL_COCOA
+  mac_init_input_method ();
+#endif
+
   as_status = 0;
   as_script = Qnil;
   as_result = 0;
diff --git a/src/nsterm.h b/src/nsterm.h
index a99b517fd5..ef38e74a6d 100644
--- a/src/nsterm.h
+++ b/src/nsterm.h
@@ -751,6 +751,8 @@ extern EmacsMenu *svcsMenu;
 #define KEY_NS_NEW_FRAME               ((1<<28)|(0<<16)|12)
 #define KEY_NS_TOGGLE_TOOLBAR          ((1<<28)|(0<<16)|13)
 #define KEY_NS_SHOW_PREFS              ((1<<28)|(0<<16)|14)
+#define KEY_MAC_CHANGE_INPUT_METHOD    ((1<<28)|(0<<16)|15)
+#define KEY_NS_PUT_MARKED_TEXT         ((1<<28)|(0<<16)|16)
 
 /* Could use list to store these, but rest of emacs has a big infrastructure
    for managing a table of bitmap "records".  */
diff --git a/src/nsterm.m b/src/nsterm.m
index 3c95fedadc..3a591a91c1 100644
--- a/src/nsterm.m
+++ b/src/nsterm.m
@@ -5263,6 +5263,9 @@ Needs to be here because ns_initialize_display_info () uses AppKit classes.
   /*   [[NSNotificationCenter defaultCenter] addObserver: NSApp
                                          selector: @selector (logNotification:)
                                              name: nil object: nil]; */
+  [[NSDistributedNotificationCenter defaultCenter] addObserver: NSApp
+					selector: @selector (changeInputMethod:)
+						   name: @"AppleSelectedInputSourcesChangedNotification" object: nil];
 
   dpyinfo = xzalloc (sizeof *dpyinfo);
 
@@ -5566,6 +5569,21 @@ - (void)logNotification: (NSNotification *)notification
     NSLog (@"notification: '%@'", [notification name]);
 }
 
+- (void)changeInputMethod: (NSNotification *)notification
+{
+
+  struct frame *emacsframe = SELECTED_FRAME ();
+
+  if (mac_store_change_input_method_event())
+    {
+      if (!emacs_event)
+	return;
+      emacs_event->kind = NS_NONKEY_EVENT;
+      emacs_event->code = KEY_MAC_CHANGE_INPUT_METHOD;
+      emacs_event->modifiers = 0;
+      EV_TRAILER ((id)nil);
+    }
+}
 
 - (void)sendEvent: (NSEvent *)theEvent
 /* --------------------------------------------------------------------------
@@ -6288,7 +6306,8 @@ In that case we use UCKeyTranslate (ns_get_shifted_character)
 
       /* If it was a function key or had control-like modifiers, pass
          it directly to Emacs.  */
-      if (fnKeysym || (emacs_event->modifiers
+      if (mac_pass_key_directly_to_emacs ()
+	  ||fnKeysym || (emacs_event->modifiers
                        && (emacs_event->modifiers != shift_modifier)
                        && [[theEvent charactersIgnoringModifiers] length] > 0))
         {
@@ -6316,9 +6335,19 @@ In that case we use UCKeyTranslate (ns_get_shifted_character)
             }
 
           emacs_event->code = code;
-          EV_TRAILER (theEvent);
-          processingCompose = NO;
-          return;
+	  /* The function mac_pass_key_to_system decides 
+	     whether it is passed directly to emacs or not. */
+	  if (emacs_event->kind == NON_ASCII_KEYSTROKE_EVENT
+	      || !mac_pass_key_to_system (code, flags
+					  & (NSShiftKeyMask
+					     | NSControlKeyMask
+					     | NSAlternateKeyMask
+					     | NSCommandKeyMask)))
+	    {
+	      EV_TRAILER (theEvent);
+	      processingCompose = NO;
+	      return;
+	    }
         }
     }
 
@@ -6430,10 +6459,19 @@ - (void)setMarkedText: (id)aString selectedRange: (NSRange)selRange
            (unsigned long)selRange.length,
            (unsigned long)selRange.location);
 
-  if (workingText != nil)
-    [self deleteWorkingText];
   if ([str length] == 0)
-    return;
+    {
+      [self deleteWorkingText];
+      return;
+    }
+  else
+    {
+      if (workingText != nil) {
+	[workingText release];
+	workingText = nil;
+	processingCompose = NO;
+      }
+    }
 
   if (!emacs_event)
     return;
@@ -6443,7 +6481,9 @@ - (void)setMarkedText: (id)aString selectedRange: (NSRange)selRange
   ns_working_text = build_string ([workingText UTF8String]);
 
   emacs_event->kind = NS_TEXT_EVENT;
-  emacs_event->code = KEY_NS_PUT_WORKING_TEXT;
+  emacs_event->code = KEY_NS_PUT_MARKED_TEXT;
+  emacs_event->arg = Fcons (make_number (selRange.location),
+			    Fcons (make_number (selRange.length), Qnil));
   EV_TRAILER ((id)nil);
 }
 
@@ -6506,18 +6546,26 @@ - (NSRect)firstRectForCharacterRange: (NSRange)theRange
 {
   NSRect rect;
   NSPoint pt;
-  struct window *win = XWINDOW (FRAME_SELECTED_WINDOW (emacsframe));
+  //  struct window *win = XWINDOW (FRAME_SELECTED_WINDOW (emacsframe));
+  struct window *win;
 
   NSTRACE ("[EmacsView firstRectForCharacterRange:]");
 
   if (NS_KEYLOG)
     NSLog (@"firstRectForCharRange request");
+    
+  if (NILP (Vmac_in_echo_area))
+    win = XWINDOW (FRAME_SELECTED_WINDOW (emacsframe));
+    else if (WINDOWP (echo_area_window))
+    win = XWINDOW (echo_area_window);
+  else
+    win = XWINDOW (FRAME_SELECTED_WINDOW (emacsframe));
 
   rect.size.width = theRange.length * FRAME_COLUMN_WIDTH (emacsframe);
   rect.size.height = FRAME_LINE_HEIGHT (emacsframe);
   pt.x = WINDOW_TEXT_TO_FRAME_PIXEL_X (win, win->phys_cursor.x);
   pt.y = WINDOW_TO_FRAME_PIXEL_Y (win, win->phys_cursor.y
-                                       +FRAME_LINE_HEIGHT (emacsframe));
+                                       +FRAME_LINE_HEIGHT (emacsframe)+2);
 
   pt = [self convertPoint: pt toView: nil];
 
@@ -9480,6 +9528,10 @@ Nil means use fullscreen the old (< 10.7) way.  The old way works better with
   x_underline_at_descent_line = 0;
   DEFSYM (Qx_underline_at_descent_line, "x-underline-at-descent-line");
 
+  DEFVAR_LISP ("mac-in-echo-area", Vmac_in_echo_area,
+               doc: /* state of cursor in echo area. */);
+  Vmac_in_echo_area = Qnil;
+
   /* Tell Emacs about this window system.  */
   Fprovide (Qns, Qnil);
 
diff --git a/src/termhooks.h b/src/termhooks.h
index 1b2c95e824..ecb15d748e 100644
--- a/src/termhooks.h
+++ b/src/termhooks.h
@@ -59,6 +59,7 @@ enum output_method
   output_x_window,
   output_msdos_raw,
   output_w32,
+  output_mac,
   output_ns
 };
 
